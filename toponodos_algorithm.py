# -*- coding: utf-8 -*-

"""
/***************************************************************************
 TopoNodos
                                 A QGIS plugin
 Extrai automaticamente os pontos de inflexão do terreno sobre redes de distribuição baseando-se em um MDT.
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2025-05-09
        copyright            : (C) 2025 by Evanderson H. Aguiar
        email                : evanderson.eng@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

__author__ = 'Evanderson H. Aguiar'
__date__ = '2025-05-09'
__copyright__ = '(C) 2025 by Evanderson H. Aguiar'

# This will get replaced with a git SHA1 when you do a git archive

__revision__ = '$Format:%H$'

# -*- coding: utf-8 -*-
from qgis.PyQt.QtCore import QCoreApplication
from qgis.core import (
    QgsProcessing,
    QgsFeatureSink,
    QgsProcessingAlgorithm,
    QgsProcessingParameterRasterLayer,
    QgsProcessingParameterFeatureSource,
    QgsProcessingParameterNumber,
    QgsProcessingParameterFeatureSink,
    QgsFeature,
    QgsPointXY,
    QgsGeometry,
    QgsFields,
    QgsField,
    QgsWkbTypes,
    QgsCoordinateTransform,
    QgsProject,
    QgsRasterLayer,
    QgsVectorLayer,
    QgsUnitTypes
)
from PyQt5.QtCore import QVariant

class TopoNodosAlgorithm(QgsProcessingAlgorithm):

    def initAlgorithm(self, config=None):
        self.addParameter(QgsProcessingParameterRasterLayer('MDS', self.tr('Modelo Digital de Superfície (Raster)')))
        self.addParameter(QgsProcessingParameterFeatureSource('TUBULACOES', self.tr('Tubulações (linhas)'), types=[QgsProcessing.TypeVectorLine]))
        self.addParameter(QgsProcessingParameterNumber('SUAVIZACAO', self.tr('Fator de suavização (m)'), type=QgsProcessingParameterNumber.Double, defaultValue=0.5, minValue=0.0))
        self.addParameter(QgsProcessingParameterNumber('PASSO_INTERPOLACAO', self.tr('Passo de interpolação (m)'), type=QgsProcessingParameterNumber.Double, defaultValue=1.0, minValue=0.1))
        self.addParameter(QgsProcessingParameterFeatureSink('SAIDA_LINHAS', self.tr('Linhas quebradas nos pontos de inflexão')))
        self.addParameter(QgsProcessingParameterFeatureSink('SAIDA_PONTOS', self.tr('Pontos de inflexão (nós com elevação)')))

    def processAlgorithm(self, parameters, context, feedback):
        mds = self.parameterAsRasterLayer(parameters, 'MDS', context)
        tubulacoes = self.parameterAsSource(parameters, 'TUBULACOES', context)
        suavizacao = self.parameterAsDouble(parameters, 'SUAVIZACAO', context)
        passo = self.parameterAsDouble(parameters, 'PASSO_INTERPOLACAO', context)

        if mds.crs().mapUnits() != QgsUnitTypes.DistanceMeters:
            feedback.reportError("O raster deve estar em um sistema de coordenadas com unidades em metros.")

        transform = None
        if tubulacoes.sourceCrs() != mds.crs():
            transform = QgsCoordinateTransform(tubulacoes.sourceCrs(), mds.crs(), QgsProject.instance())

        campos_pontos = QgsFields()
        campos_pontos.append(QgsField('elev', QVariant.Double))
        campos_pontos.append(QgsField('id_linha', QVariant.Int))

        campos_linhas = tubulacoes.fields()

        sink_pontos, saida_pontos_id = self.parameterAsSink(parameters, 'SAIDA_PONTOS', context, campos_pontos, QgsWkbTypes.Point, mds.crs())
        sink_linhas, saida_linhas_id = self.parameterAsSink(parameters, 'SAIDA_LINHAS', context, campos_linhas, QgsWkbTypes.LineString, mds.crs())


        pontos_registrados = set()

        for i, feat in enumerate(tubulacoes.getFeatures()):
            if feedback.isCanceled():
                break

            geom = feat.geometry()
            if geom.isMultipart():
                linhas = geom.asMultiPolyline()
            else:
                linhas = [geom.asPolyline()]

            for linha in linhas:
                geom_linha = QgsGeometry.fromPolylineXY(linha)

                if transform:
                    geom_linha.transform(transform)

                coords_linha = geom_linha.asPolyline()

                inflexoes = self.extrair_inflexoes(geom_linha, mds, passo, suavizacao)

                # inclui início e fim com elevação
                inflexoes = [(coords_linha[0], self.amostrar_elevacao(coords_linha[0], mds))] + \
                            inflexoes + \
                            [(coords_linha[-1], self.amostrar_elevacao(coords_linha[-1], mds))]

                for pt, elev in inflexoes:
                    key = (round(pt.x(), 4), round(pt.y(), 4))
                    if key not in pontos_registrados:
                        f = QgsFeature()
                        f.setGeometry(QgsGeometry.fromPointXY(pt))
                        f.setFields(campos_pontos)
                        f.setAttribute('elev', elev)
                        f.setAttribute('id_linha', feat.id())
                        sink_pontos.addFeature(f, QgsFeatureSink.FastInsert)
                        pontos_registrados.add(key)

                indices = self.encontrar_indices_inflexao(inflexoes, coords_linha)
                indices = sorted(set(indices))
                if indices:
                    segmentos = []
                    for a, b in zip(indices[:-1], indices[1:]):
                        segmento = coords_linha[a:b+1]
                        if len(segmento) >= 2:
                            nova = QgsFeature(feat)
                            nova.setGeometry(QgsGeometry.fromPolylineXY(segmento))
                            sink_linhas.addFeature(nova, QgsFeatureSink.FastInsert)
                else:
                    nova = QgsFeature(feat)
                    nova.setGeometry(geom_linha)
                    sink_linhas.addFeature(nova, QgsFeatureSink.FastInsert)

            feedback.setProgress(int(100 * i / tubulacoes.featureCount()))

        return {
            'SAIDA_LINHAS': saida_linhas_id,
            'SAIDA_PONTOS': saida_pontos_id
        }

    def extrair_inflexoes(self, geom_linha, raster, passo, suavizacao):
        comprimento = geom_linha.length()
        n_pontos = int(comprimento // passo) + 1
        pontos = []
        elevacoes = []

        for i in range(n_pontos):
            dist = i * passo
            pt = geom_linha.interpolate(dist).asPoint()

            if not raster.extent().contains(QgsPointXY(pt)):
                continue

            resultado = raster.dataProvider().sample(QgsPointXY(pt), 1)
            if resultado[1] is False or resultado[0] is None:
                continue

            pontos.append(QgsPointXY(pt))
            elevacoes.append(resultado[0])

        inflexoes = []
        for i in range(1, len(elevacoes) - 1):
            anterior = elevacoes[i - 1]
            atual = elevacoes[i]
            proximo = elevacoes[i + 1]

            delta1 = atual - anterior
            delta2 = proximo - atual

            mudou_direcao = delta1 * delta2 < 0
            variacao_total = abs(delta1) + abs(delta2)

            if mudou_direcao and variacao_total >= suavizacao:
                inflexoes.append((pontos[i], atual))

        return inflexoes

    def amostrar_elevacao(self, pt, raster):
        if not raster.extent().contains(pt):
            return None
        resultado = raster.dataProvider().sample(QgsPointXY(pt), 1)
        return resultado[0] if resultado[1] else None

    def encontrar_indices_inflexao(self, inflexoes, pontos, tolerancia=0.01):
        indices = []
        for pt, _ in inflexoes:
            idx = min(range(len(pontos)), key=lambda i: pt.distance(pontos[i]))
            if pt.distance(pontos[idx]) <= tolerancia:
                indices.append(idx)
        return indices

    def name(self):
        return 'TopoNodos'

    def displayName(self):
        return self.tr(self.name())

    def group(self):
        return self.tr(self.groupId())

    def groupId(self):
        return 'analise_altimetrica'

    def tr(self, string):
        return QCoreApplication.translate('Processing', string)

    def createInstance(self):
        return TopoNodosAlgorithm()